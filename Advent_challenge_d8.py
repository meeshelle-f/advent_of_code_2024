# -*- coding: utf-8 -*-
"""Copy of Advent Challenge D8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1m8-8INFdThXoQz7-HxtBmsgLrlKM1kP8
"""

from google.colab import drive
drive.mount('/content/drive')

file_path = '/content/drive/MyDrive/Advent 2024/day8/d8_input.txt'

import numpy as np
import pandas as pd

"""##Day 8 Part 1 info

--- Day 8: Resonant Collinearity ---
You find yourselves on the roof of a top-secret Easter Bunny installation.

While The Historians do their thing, you take a look at the familiar huge antenna. Much to your surprise, it seems to have been reconfigured to emit a signal that makes people 0.1% more likely to buy Easter Bunny brand Imitation Mediocre Chocolate as a Christmas gift! Unthinkable!

Scanning across the city, you find that there are actually many such antennas. **Each antenna is tuned to a specific frequency indicated by a single lowercase letter, uppercase letter, or digit. You create a map (your puzzle input) of these antennas.** For example:
"""

text_string

import re

def grab_antennas(data_list_str):
  antenna_dict = {}
  rows= len(data_list_str)
  cols = len(data_list_str[0])

  for i in range(rows):
    for j in range(cols):
      if data_list_str[i][j] != '.':
        freq = data_list_str[i][j]

        if freq not in antenna_dict.keys():
          antenna_dict[freq] = [(i,j)]
        else:
          antenna_dict[freq].append((i,j))
  boundaries = [rows, cols]
  return antenna_dict, boundaries

import itertools
from itertools import product

from collections import Counter
from collections import defaultdict


def find_antinodes(coord_1, coord_2):
    antinodes = []

    x1, y1 = coord_1
    x2, y2 = coord_2
    diff_x = x1 - x2
    diff_y = y1 - y2

    antinode_1, antinode_2 = 0, 0
    if diff_x <0 and diff_y>0:  #neg slope
      # print(coord_1, coord_2, 'negative slope!', diff_x, diff_y )
      antinode_1 = (x2 + abs(diff_x), y2 - diff_y)
      antinode_2= (x1 + diff_x, y1 + diff_y)

    elif diff_x >0 and diff_y<0:  #neg slope
      antinode_1 = x2 + diff_x, y2 + diff_y
      antinode_2= x1 - diff_x, y1 + abs(diff_y)

    else:
      if diff_x>0 and diff_y>0:
        antinode_1 = x2 - diff_x, y2 - diff_y # 3 - 2, 4 - 1
        antinode_2= x1 + diff_x, y1 + diff_y  #5 + 2, 5 + 1

      else: # diff_x<0 and diff_y<0:
        antinode_1 = x2 + abs(diff_x), y2 + abs(diff_y) #5 - (-2), 5 + (-1)
        antinode_2= x1 + diff_x, y1 + diff_y # 3 + (-2), 4 + (-1)

    # print(antinode_1, antinode_2)
    return antinode_1, antinode_2


def identify_collinear_antennas(antenna_dict):

  total_antinodes = 0
  all_antenna_coords = set(value for values in antenna_dict.values() for value in values)

  for key in antenna_dict.keys():
    # collinear_dict = {}

    antenna_coords = antenna_dict[key]
    all_combos = itertools.combinations(antenna_coords, 2) # Generate all combinations of length num_combos

    for coord_1, coord_2 in all_combos:
      x1, y1 = coord_1
      x2, y2 = coord_2
      slope = (x1 - x2) / (y1-y2) #y/x vs x/y doesnt matter?
      # collinear_dict[(coord_1, coord_2)] = slope

      antinode_1, antinode_2 = find_antinodes(coord_1,coord_2)
      print('coord1',coord_1, 'coord2', coord_2, 'slope', slope, 'ant1', antinode_1, 'ant2', antinode_2)

      if 0<= antinode_1[0] <= boundaries[1] and 0<= antinode_1[1] <= boundaries[1] and antinode_1 not in all_antenna_coords:
        print('ant1 pass!', antinode_1)
        total_antinodes+=1
      else:
        print('ant1 fail!', antinode_1)

      if 0<= antinode_2[0] <= boundaries[1] and 0<= antinode_2[1] <= boundaries[1] and antinode_2 not in all_antenna_coords:
        print('ant2 pass!', antinode_2)
        total_antinodes+=1
      else:
        print('ant2 fail!', antinode_2)

  print('total_antinodes', total_antinodes)

data_str_a = """............
........0...
.....0......
.......0....
....0.......
......A.....
............
............
........A...
.........A..
............
............"""

# Data in differnt formats for quick access
lines = data_str_a.split("\n")
grid = [list(line) for line in lines]
antenna_dict,boundaries = grab_antennas(grid)
antenna_dict #{'0': [(1, 8), (2, 5), (3, 7), (4, 4)], 'A': [(5, 6), (8, 8), (9, 9)]}
identify_collinear_antennas(antenna_dict)

# boundaries #0-11 rows and 0-11 columns (AKA 12x12)
#total_antinodes 14

"""**test example 2....**"""

data_str_b_no_antenna = """..........
..........
..........
....a.....
..........
.....a....
..........
..........
..........
.........."""

lines = data_str_b_no_antenna.split("\n")
grid = [list(line) for line in lines]
antenna_dict,boundaries = grab_antennas(grid)
boundaries #[10, 10]
antenna_dict #{'a': [(3, 4), (5, 5)]}
identify_collinear_antennas(antenna_dict) #total_antinodes 2

data_str_c_no_antenna = """..........
..........
..........
....a.....
........a.
.....a....
..........
..........
..........
.........."""

lines = data_str_c_no_antenna.split("\n")
grid = [list(line) for line in lines]
antenna_dict,boundaries = grab_antennas(grid)
antenna_dict #{'a': [(3, 4), (4, 8), (5, 5)]}
identify_collinear_antennas(antenna_dict) #total_antinodes 4

"""##part 1 real"""

prod_str = """...........................A.............W........
.......x..........AZ......P.........m......k..W...
....v.....Z..K...V..........A.......R....f........
.............d..........V.............2...........
.........Z........d...V.....B....C.....e..........
............Z.vA...........m...................s.W
...x..o.....................ek....................
...O.....VK..................R......B.............
.........O..................my....kB..............
.v...................y..........C........B.....z..
xb.v..................................C..z........
.........................2.ey.....................
..K.......................y...................s...
..........................................z.......
.......................2.......R........z......F..
O.....d..................D..k.........F...........
..........O..........D.............s....E.........
..o......9....................D........C..s.......
.....o..r....................c...................m
.......P..............................e...........
..............1......................d............
...................o...............3..............
........................c.......24..........S.....
....x..................c.............F4.........S.
P............N..8.......W.D.......................
.....K............1.8.............................
.........P..............Q...M.....................
9...................R........4...8.....0..........
....n.........................F...................
........Y...n......1......................3..J....
.........................3...8....................
...n...M............................0.......ja...S
....f................................6.....S.....E
....................i.........M...J...............
...r..........q..........1......l..0.....L........
.........f7....i.Nc......................j.......l
..9....Y7......X.........Q...M5....J4...........3.
.Y........NX..I............Q........L.............
......Xw...nb.............0..............l6.......
......b.....f....5..q.....................a..6....
.......5..........iq.9.....p..........a...........
........X........I................p...6...........
..................N.............L.........j.......
...b.7.......................p....Q......E........
....Y....7......................p................j
.......r..........................................
.................i...................a............
..w.........5.....................................
......w........I..............J...................
.w............r.....................lL............"""

lines = prod_str.split("\n")
grid = [list(line) for line in lines]
antenna_dict,boundaries = grab_antennas(grid) # [50, 50]
identify_collinear_antennas(antenna_dict) # 369

"""##part 2 info

--- Part Two ---
Watching over your shoulder as you work, one of The Historians asks if you took the effects of resonant harmonics into your calculations.

Whoops!

After updating your model, it turns out that an antinode occurs at any grid position exactly in line with at least two antennas of the same frequency, regardless of distance. This means that some of the new antinodes will occur at the position of each antenna (unless that antenna is the only one of its frequency).

So, these three T-frequency antennas now create many antinodes:
"""

data_str_a = """T.........
...T......
.T........
..........
..........
..........
..........
..........
..........
.........."""

# """T....#....
# ...T......
# .T....#...
# .........#
# ..#.......
# ..........
# ...#......
# ..........
# ....#.....
# .........."""

#In fact, the three T-frequency antennas are all exactly in line with two antennas, so they are all also antinodes! This brings the total number of antinodes in the above example to 9.
# The original example now has 34 antinodes, including the antinodes that appear on every antenna:

data_str_b = """##....#....#
.#.#....0...
..#.#0....#.
..##...0....
....0....#..
.#...#A....#
...#..#.....
#....#.#....
..#.....A...
....#....A..
.#........#.
...#......##"""

import itertools
from itertools import product

from collections import Counter
from collections import defaultdict

#rewrite

def find_antinodes(coord_1, coord_2):
  in_bounds = True
  antinode_1_in_bounds, antinode_2_in_bounds = True, True
  antinodes = []
  i= 0
  x1, y1 = coord_1
  x2, y2 = coord_2
  diff_x = x1 - x2
  diff_y = y1 - y2

  while in_bounds:

    i+=1

    if diff_x <0 and diff_y>0:  #neg slope
      # print(coord_1, coord_2, 'negative slope!', diff_x, diff_y )
      antinode_1 = (x2 + abs(diff_x)*i, y2 - diff_y*i)
      antinode_2= (x1 + diff_x*i, y1 + diff_y*i)

    elif diff_x >0 and diff_y<0:  #neg slope
      antinode_1 = (x2 + diff_x*i, y2 + diff_y*i)
      antinode_2 = (x1 - diff_x*i, y1 + abs(diff_y*i))

    else:
      if diff_x>0 and diff_y>0:
        antinode_1 = (x2 - diff_x*i, y2 - diff_y*i) # 3 - 2, 4 - 1
        antinode_2= (x1 + diff_x*i, y1 + diff_y*i)  #5 + 2, 5 + 1

      else: # diff_x<0 and diff_y<0:
        antinode_1 = (x2 + abs(diff_x)*i, y2 + abs(diff_y)*i) #5 - (-2), 5 + (-1)
        antinode_2= (x1 + diff_x*i, y1 + diff_y*i) # 3 + (-2), 4 + (-1)

    # print(i, antinode_1[0],antinode_1[1], antinode_2[0], antinode_2[1])

    if 0 > antinode_1[0] or 0 > antinode_1[1] or antinode_1[0]>= boundaries[1] or antinode_1[1]>= boundaries[1]:
      # print('boundary broken for antinode1', antinode_1)
      antinode_1_in_bounds = False
    else:
        antinodes.append(antinode_1)

    if 0 > antinode_2[0] or 0 > antinode_2[1] or antinode_2[0]>= boundaries[1] or antinode_2[1]>= boundaries[1]:
      # print('boundary broken for antinode2', antinode_2)
      antinode_2_in_bounds = False
    else:
      antinodes.append(antinode_2)

    if not antinode_1_in_bounds and not antinode_2_in_bounds:
      in_bounds = False
      break

  return antinodes


def find_antinodes_w_vectors(antenna_dict):

  total_antinodes = 0
  all_antenna_coords = set(value for values in antenna_dict.values() for value in values)
  noted_antinodes = []

  for key in antenna_dict.keys():
    antenna_coords = antenna_dict[key]
    all_combos = itertools.combinations(antenna_coords, 2) # Generate all combinations of length num_combos

    for coord_1, coord_2 in all_combos:
      antinodes = find_antinodes(coord_1,coord_2)
      # print('antinodes', antinodes)

      for antinode in antinodes:
        if antinode not in all_antenna_coords and antinode not in noted_antinodes:
          noted_antinodes.append(antinode)
          # print('ant pass!', antinode)
          total_antinodes+=1


  print('total_antinodes', total_antinodes)
  tt = total_antinodes + len( all_antenna_coords)
  print('total_antinodes + total antennas', tt)

lines = data_str_a.split("\n")
grid = [list(line) for line in lines]
antenna_dict,boundaries = grab_antennas(grid)
find_antinodes_w_vectors(antenna_dict) #6 + antennas (3) = 9

"""**Calculate the impact of the signal using this updated model. How many unique locations within the bounds of the map contain an antinode?**

Option one, put a printing press next to the guard's starting position:

##Part 2 example

It doesn't really matter what you choose to use as an obstacle so long as you and The Historians can put it into position without the guard noticing. The important thing is having enough options that you can find one that minimizes time paradoxes, and in this example, there are 6 different positions you could choose.

**You need to get the guard stuck in a loop by adding a single new obstruction. How many different positions could you choose for this obstruction?**
"""

#test prod part 2 here
lines = prod_str.split("\n")
grid = [list(line) for line in lines]
antenna_dict,boundaries = grab_antennas(grid)
identify_collinear_antennas(antenna_dict)

#total_antinodes 956
# total_antinodes + total antennas 1169