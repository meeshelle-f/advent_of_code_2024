# -*- coding: utf-8 -*-
"""Advent Challenge D9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c_HvLgTHRKo7l7TG3Fvb2OGCXtup_Lyz
"""

from google.colab import drive
drive.mount('/content/drive')

file_path = '/content/drive/MyDrive/Advent 2024/day9/d9_input.txt'

import numpy as np
import pandas as pd

"""##Day 9 Part 1 info

--- Day 9: Disk Fragmenter ---
Another push of the button leaves you in the familiar hallways of some friendly amphipods! Good thing you each somehow got your own personal mini submarine. The Historians jet away in search of the Chief, mostly by driving directly into walls.

While The Historians quickly figure out how to pilot these things, you notice an amphipod in the corner struggling with his computer. He's trying to make more contiguous free space by compacting all of the files, but his program isn't working; you offer to help.

He shows you the disk map (your puzzle input) he's already generated. For example:
"""

disk_map_ex = '2333133121414131402'

# The first example above, 2333133121414131402, represents these individual blocks:

# x= (type) file block, x = # file blocks
# y= (type) free block, y = # free blocks '.'

# [xy]
# 2  3  3  3 1 3  3
# 00...111...2...333

"""The first example above, 2333133121414131402, represents these individual blocks:

00...111...2...333.44.5555.6666.777.888899

The disk map uses a dense format to represent the layout of files and free space on the disk. **The digits alternate between indicating the length of a file and the length of free space.**

Each file on disk also has an ID number based on the order of the files as they appear before they are rearranged, starting with ID 0.

So, the disk map 12345 has three files: a one-block file with ID 0, a three-block file with ID 1, and a five-block file with ID 2.
"""

# 12345
#1-block file, 2 blocks of free space, a 3-block file, 4 blocks of free space, and then a 5-block file.
# 3 total files with blocks: [1,3,5] and ids: [0,1,2]
# 6 blocks of file space [2,4]

##Using one character for each block where digits are the file ID and . is free space, the disk map 12345 represents these individual blocks:
# 0..111....22222

# 90909
# 3 9-block files in a row (with no free space between them).

"""The amphipod would like to move file blocks one at a time from the end of the disk to the leftmost free space block (until there are no gaps remaining between file blocks). For the disk map 12345, the process looks like this:

"""

#initial seq
# 12345

#after transformation:
# 0..111....22222

# 0..111....22222
# 02.111....2222.
# 022111....222..
# 0221112...22...
# 02211122..2....
# 022111222......

"""The final step of this file-compacting process is to update the filesystem checksum. To calculate the checksum, add up the result of multiplying each of these blocks' position with the file ID number it contains. The leftmost block is in position 0. If a block contains free space, skip it instead.

Continuing the first example, the first few blocks' position multiplied by its file ID number are 0 * 0 = 0, 1 * 0 = 0, 2 * 9 = 18, 3 * 9 = 27, 4 * 8 = 32, and so on. In this example, the checksum is the sum of these, 1928.

###create example function
"""

def check_even_odd(num):
  if num % 2 == 0:
    return "even"
  else:
    return "odd"

def transform_str(digits_str):
  transform_str = ""

  store_id = 0
  for i in range(len(ex_str)):

    if check_even_odd(i) == 'even': #even is file block
      if i !=0:
        store_id += 1

      # i = file id
      # multiply by the digit at index i
      transform_str += (str(store_id) * int(ex_str[i]))

    else: #odd is free block
      # '.' = free block
      # multiply by the digit at index i
      transform_str += ('.' * int(ex_str[i]))
  return transform_str

def correct_order(transformed_str):
  found_period = False
  for i, char in enumerate(transformed_str):
    # print(i, char)

    if char=='.':
      prev_char = char
      found_period = True

    elif found_period and char.isdigit():
      # print("FAIL", 'prev_char', prev_char, 'char', char)
      return False

  return True #true means no '.' come before digits

import re

def find_periods(string):
    matches = re.finditer(r"\.", string)
    period_indices = [match.start() for match in matches]
    return period_indices

def correct_string(t_str):
  period_indices = find_periods(t_str)
  # print('period_indices:',period_indices)

  v = len(t_str)
  while not correct_order(t_str): #AKA is not passing. is incorrect

    ##optimize using single pass to find period indices
    period_indices = find_periods(t_str)
    j = 0
    #find last digit in string
    for i, char in enumerate(reversed(t_str)):
      if char.isdigit():
        last_digit_index= (v - 1) - i  #len(transformed_str) #15 -1
        # print(last_digit_index, 'of', v)
        # break

        first_period_index = period_indices[j] #start at 0?
        j+=1
        if first_period_index < last_digit_index: #
          t_str = t_str[:first_period_index] + t_str[last_digit_index] + t_str[first_period_index + 1:last_digit_index] + '.' + t_str[last_digit_index + 1:]
          # print(t_str)
        if correct_order(t_str):
          return t_str
          break



def final_checksum(corrected_string):
  checksum = 0
  correct_i = 0
  for i, char in enumerate (corrected_string):
    if char.isdigit():
      print('i:', correct_i, 'char:', char, '(i)*int(char):', (correct_i)*int(char))
      checksum+= (correct_i)*int(char)
      correct_i +=1

      print('checksum:',checksum)
  return checksum

ex_str = "12345"
print(f'input string:', ex_str)
transformed_str= transform_str(ex_str)

print(f'incorrect string:', transformed_str)
corrected_string = correct_string(transformed_str)
print(f'corrected string:', corrected_string)

checksum = final_checksum(corrected_string)
print(f'checksum:', checksum)
# input string: 12345
# checksum: 60

"""###enhance example function to use tuples instead of strings"""

#first transformation converts str to int
#identifies file types (empty or id) and sizes
#return list of tuples in format (id, size)

def t1(text):
  list_of_tuples = [] #convert input list of strings into list of tuples
  file_id = 0
  int_input = [int(c) for c in text if c.isdigit()]

  for i in range(len(int_input)):
    if i % 2 == 0: # even means type = file
      list_of_tuples.append((file_id, int_input[i]))
      file_id += 1
    else: # odd means type = empty
      list_of_tuples.append((None, int_input[i]))
  return list_of_tuples

#pulls the last file id
def pop_last_digit_file(data: list):
  for i, (id, size) in enumerate(reversed(data)):
      # print('i',i, 'id',id, 'size',size)
      if id != None:
          data.pop(len(data) - 1 - i)
          return (id, size)
  return (-1, -1)


def free_file_space(data): #find first free file space
    for i, (id, _) in enumerate(data):
        if id == None:
            return i
    return -1


def done(data):
  p = free_file_space(data)
  #print p
  # print('p:', p)
  for i in range(p, len(data)):
      # print('i', i, 'data[i][0]',data[i][0])
      if data[i][0] != None: #if file block return false
          return False
  return True #if file space return true



def perform_transformations(text):
  data = t1(text)
  print('data:', data) #data: [(0, 1), (None, 2), (1, 3), (None, 4), (2, 5)]

  lf = pop_last_digit_file(data)

  while not done(data): #if file exists after free space return False
    fsi = free_file_space(data)
    diff = lf[1] - data[fsi][1] #grab last digit - grab size of space
    if diff > 0:
        data[fsi] = (lf[0], data[fsi][1])
        lf = (lf[0], diff)
        data.append((None, data[fsi][1]))
        # print('data:',data)
    if diff < 0:
        data[fsi] = (lf[0], lf[1])
        data.append((None, lf[1]))
        lf = pop_last_digit_file(data)
        data.insert(fsi + 1, (None, abs(diff)))
    if diff == 0:
        data[fsi] = (lf[0], lf[1])
        data.append((None, lf[1]))
        lf = pop_last_digit_file(data)
  data.insert(free_file_space(data), lf)
  c, vpos = 0, 0
  for i in range(len(data)):
      if data[i][0] == None:
          break
      for j in range(vpos, vpos + data[i][1]):
          c += data[i][0] * j
      vpos += data[i][1]
  return c

# text = "12345"
# perform_transformations(text)

"""###Test str vs tuple code EX1"""

ex_str = "12345"
transformed_str= transform_str(ex_str)
corrected_string = correct_string(transformed_str)
checksum = final_checksum(corrected_string)
print(f'checksum:', checksum)

text = "12345"
perform_transformations(text)

"""###Test EX2"""

ex_str = "2333133121414131402"

transformed_str= transform_str(ex_str)
corrected_string = correct_string(transformed_str)
checksum = final_checksum(corrected_string)
print(f'checksum:', checksum)

perform_transformations(ex_str)

"""##Part 1 real

string function does not work because once file id = 10 all bets are off
"""

with open(file_path,'r') as file:
  lines = file.readline().strip() #str
  # lines = file.readlines() #list
print(type(lines), lines)

ex_str = '000000000000000000012'  #checksum = 10
# ex_str = '0000000000000000012'  #checksum = 9

perform_transformations(ex_str) #283486

ex_str = '000000000000000000012'  #checksum = 4??!!
# ex_str = '0000000000000000012' #checksum = 9

transformed_str= transform_str(ex_str)
corrected_string = correct_string(transformed_str)
checksum = final_checksum(corrected_string)
print(checksum) # once file id = 10 all bets are off with the string function! yikers.

perform_transformations(lines) #6242766523059

"""##Part 2
Upon completion, two things immediately become clear. First, the disk definitely has a lot more contiguous free space, just like the amphipod hoped. Second, the computer is running much more slowly! Maybe introducing all of that file system fragmentation was a bad idea?

The eager amphipod already has a new plan: rather than move individual blocks, he'd like to try compacting the files on his disk by moving whole files instead.

This time, attempt to move whole files to the leftmost span of free space blocks that could fit the file. Attempt to move each file exactly once in order of decreasing file ID number starting with the file with the highest file ID number. If there is no span of free space to the left of a file that is large enough to fit the file, the file does not move.
"""

#initial seq
# 12345

#after transformation:
# 0..111....22222

# 0..111....22222
# 02.111....2222.
# 022111....222..
# 0221112...22...
# 02211122..2....
# 022111222......

ex = '2333133121414131402'
# 00...111...2...333.44.5555.6666.777.888899
# 0099.111...2...333.44.5555.6666.777.8888..
# 0099.1117772...333.44.5555.6666.....8888..
# 0099.111777244.333....5555.6666.....8888..
# 00992111777.44.333....5555.6666.....8888..

"""install debugger

**incorrect (my code)**
"""

!pip install -Uqq ipdb
import ipdb

"""**rewrite**"""

# %debug

def parse_input(text):
  list_of_tuples = [] #convert input list of strings into list of tuples
  file_id = 0
  int_input = [int(c) for c in text if c.isdigit()]

  for i in range(len(int_input)):
    if i % 2 == 0: # even means type = file
      list_of_tuples.append((file_id, int_input[i]))
      file_id += 1
    else: # odd means type = empty
      list_of_tuples.append((None, int_input[i]))
  return list_of_tuples

def free_file_space(data, digit_range, digit_size): #find first free file space
    for i, (id, size) in enumerate(data):
      if i < digit_range and id == None and size >=digit_size: #empty space must be left of files
          return i

def p2(text): #p2

  data = parse_input(text)
  # ipdb.set_trace()

  for i in range(len(data)):
    c_index = len(data)-i-1
    id,size = data[c_index]

    if id != None: #id is not None

      e_index = free_file_space(data, c_index, size) #grab leftmost free file space

      if e_index: #free space exists left of file space
        e_tuple, e_size = data[e_index], data[e_index][1]

        diff = size - e_size
        if diff < 0:
            data[e_index] = (id, size)
            data[c_index] = (None, size)
            data.insert(e_index+1, (None, abs(diff)))

        if diff == 0:

            data[e_index] = (id, size) #size stays same
            data[c_index] = (None, size)

  # print('fin data:', data)

  c, vpos = 0, 0
  for i in range(len(data)):
      if data[i][0] != None:
          for j in range(vpos, vpos + data[i][1]):
              c += data[i][0] * j
      vpos += data[i][1]
  return c

t= '2333133121414131402'
print(p2(t))

"""##Part 2B"""

with open(file_path,'r') as file:
  lines = file.readline().strip() #str
  # lines = file.readlines() #list
print(type(lines), lines)

print(p2(lines)) #6272188244509